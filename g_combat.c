// g_combat.c

#include "g_local.h"
#include "g_tourney.h"

/*
============
CanDamage

Returns true if the inflictor can directly damage the target.  Used for
explosions and melee attacks.
============
*/
qboolean CanDamage (edict_t *targ, edict_t *inflictor)
{
	vec3_t	dest;
	trace_t	trace;

// bmodels need special checking because their origin is 0,0,0
	if (targ->movetype == MOVETYPE_PUSH)
	{
		VectorAdd (targ->absmin, targ->absmax, dest);
		VectorScale (dest, 0.5, dest);
		trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor, MASK_SOLID);
		if (trace.fraction == 1.0)
			return true;
		if (trace.ent == targ)
			return true;
		return false;
	}
	
	trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, targ->s.origin, inflictor, MASK_SOLID);
	if (trace.fraction == 1.0)
		return true;

	VectorCopy (targ->s.origin, dest);
	dest[0] += 15.0;
	dest[1] += 15.0;
	trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor, MASK_SOLID);
	if (trace.fraction == 1.0)
		return true;

	VectorCopy (targ->s.origin, dest);
	dest[0] += 15.0;
	dest[1] -= 15.0;
	trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor, MASK_SOLID);
	if (trace.fraction == 1.0)
		return true;

	VectorCopy (targ->s.origin, dest);
	dest[0] -= 15.0;
	dest[1] += 15.0;
	trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor, MASK_SOLID);
	if (trace.fraction == 1.0)
		return true;

	VectorCopy (targ->s.origin, dest);
	dest[0] -= 15.0;
	dest[1] -= 15.0;
	trace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor, MASK_SOLID);
	if (trace.fraction == 1.0)
		return true;


	return false;
}


/*
============
Killed
============
*/
void Killed (edict_t *targ, edict_t *inflictor, edict_t *attacker, int damage, vec3_t point)
{
	if (targ->health < -999)
		targ->health = -999;

	targ->enemy = attacker;

	if (attacker && attacker->client && Q_stricmp(attacker->client->pers.weapon->classname, "weapon_railgun") == 0)
	{
		stats_add(attacker, STATS_RAIL_KILL, 1); // BUZZKILL - IMPROVED ANALYTICS - RAIL STATS
		stats_add(attacker, SQL_RAIL_KILL, 1); // BUZZKILL - SQLITE STATS - RAIL STATS
	}

#ifdef MONSTERS_OK
	if ((targ->svflags & SVF_MONSTER) && (targ->deadflag != DEAD_DEAD))
	{
//		targ->svflags |= SVF_DEADMONSTER;	// now treat as a different content type
		if (!(targ->monsterinfo.aiflags & AI_GOOD_GUY))
		{
			level.killed_monsters++;
			if (coop->value && attacker->client)
			{
				stats_add(attacker, STATS_SCORE, 1);
				stats_add(attacker, SQL_SCORE, 1); // BUZZKILL - SQLITE STATS
				attacker->client->resp.score++;
			}
			// medics won't heal monsters that they kill themselves
			if (strcmp(attacker->classname, "monster_medic") == 0)
				targ->owner = attacker;
		}
	}
#endif

	if (targ->movetype == MOVETYPE_PUSH || targ->movetype == MOVETYPE_STOP || targ->movetype == MOVETYPE_NONE)
	{	// doors, triggers, etc
		targ->die (targ, inflictor, attacker, damage, point);
		return;
	}

#ifdef MONSTERS_OK
	if ((targ->svflags & SVF_MONSTER) && (targ->deadflag != DEAD_DEAD))
	{
		targ->touch = NULL;
		monster_death_use (targ);
	}
#endif

	targ->die (targ, inflictor, attacker, damage, point);
}


/*
================
SpawnDamage
================
*/
void SpawnDamage (int type, vec3_t origin, vec3_t normal, int damage)
{
	if (damage > 255)
		damage = 255;
	gi.WriteByte (svc_temp_entity);
	gi.WriteByte (type);
//	gi.WriteByte (damage);
	gi.WritePosition (origin);
	gi.WriteDir (normal);
	gi.multicast (origin, MULTICAST_PVS);
}


/*
============
T_Damage

targ		entity that is being damaged
inflictor	entity that is causing the damage
attacker	entity that caused the inflictor to damage targ
	example: targ=monster, inflictor=rocket, attacker=player

dir			direction of the attack
point		point at which the damage is being inflicted
normal		normal vector from that point
damage		amount of damage being inflicted
knockback	force to be applied against targ as a result of the damage

dflags		these flags are used to control how T_Damage works
	DAMAGE_RADIUS			damage was indirect (from a nearby explosion)
	DAMAGE_NO_ARMOR			armor does not protect from this damage
	DAMAGE_ENERGY			damage is from an energy based weapon
	DAMAGE_NO_KNOCKBACK		do not affect velocity, just view angles
	DAMAGE_BULLET			damage is from a bullet (used for ricochets)
	DAMAGE_NO_PROTECTION	kills godmode, armor, everything
============
*/
static int CheckPowerArmor (edict_t *ent, vec3_t point, vec3_t normal, int damage, int dflags)
{
	gclient_t	*client;
	int			save;
	int			power_armor_type;
	int			index = 0; //MJD Fixes Compiler Warning
	int			damagePerCell;
	int			pa_te_type;
	int			power=0;
	int			power_used;

	if (!damage)
		return 0;

	client = ent->client;

	if (dflags & DAMAGE_NO_ARMOR)
		return 0;

	if (client)
	{
		power_armor_type = PowerArmorType (ent);
		if (power_armor_type != POWER_ARMOR_NONE)
		{
			index = ITEM_INDEX(FindItem("Cells"));
			power = client->pers.inventory[index];
		}
	}
#ifdef MONSTERS_OK
	else if (ent->svflags & SVF_MONSTER)
	{
		power_armor_type = ent->monsterinfo.power_armor_type;
		power = ent->monsterinfo.power_armor_power;
	}
#endif
	else
		return 0;

	if (power_armor_type == POWER_ARMOR_NONE)
		return 0; //MJD This catches the uninitilized index
		          //case, but I initilized it anyway...
	if (!power)
		return 0;

	if (power_armor_type == POWER_ARMOR_SCREEN)
	{
		vec3_t		vec;
		float		dot;
		vec3_t		forward;

		// only works if damage point is in front
		AngleVectors (ent->s.angles, forward, NULL, NULL);
		VectorSubtract (point, ent->s.origin, vec);
		VectorNormalize (vec);
		dot = DotProduct (vec, forward);
		if (dot <= 0.3)
			return 0;

		damagePerCell = 1;
		pa_te_type = TE_SCREEN_SPARKS;
#ifdef WEAP_BALANCE_OK	
		if ((int)ctfflags->value & CTF_WEAP_BALANCE) // LM_Jorm -- Reduce effectiveness
			damage = damage / 8;
		else
			damage = damage / 3;
#else
	  	damage = damage / 3;
#endif

	}
	else
	{
		damagePerCell = 1;
		if ((int)ctfflags->value & CTF_DM_POWER_ARMOR_STRENGTH)
			damagePerCell++;
		pa_te_type = TE_SHIELD_SPARKS;

#ifdef WEAP_BALANCE_OK
		if ((int)ctfflags->value & CTF_WEAP_BALANCE) // LM_Jorm -- Reduce effectiveness
			damage = damage / 4;
		else
			damage = (2 * damage) / 3;
#else
	  	damage = (2 * damage) / 3;
#endif

	}

	save = power * damagePerCell;
	if (!save)
		return 0;
	if (save > damage)
		save = damage;

	SpawnDamage (pa_te_type, point, normal, save);
	ent->powerarmor_time = level.time + 0.2;

	power_used = save / damagePerCell;

#ifdef WEAP_BALANCE_OK	
	if ((int)ctfflags->value & CTF_WEAP_BALANCE) //surt, cells get sucked faster
		power_used *= 3;
#endif

	if (client)
		client->pers.inventory[index] -= power_used;
	else
		ent->monsterinfo.power_armor_power -= power_used;
	return save;
}

static int CheckArmor (edict_t *ent, vec3_t point, vec3_t normal, int damage, int te_sparks, int dflags)
{
	gclient_t	*client;
	int			save;
	int			index;
	gitem_t		*armor;

	if (!damage)
		return 0;

	client = ent->client;

	if (!client)
		return 0;

	if (dflags & DAMAGE_NO_ARMOR)
		return 0;

	index = ArmorIndex (ent);
	if (!index)
		return 0;

	armor = GetItemByIndex (index);

	if (dflags & DAMAGE_ENERGY)
		save = ceilf(((gitem_armor_t *)armor->info)->energy_protection*damage);
	else
		save = ceilf(((gitem_armor_t *)armor->info)->normal_protection*damage);
	if (save >= client->pers.inventory[index])
		save = client->pers.inventory[index];

	if (!save)
		return 0;

	client->pers.inventory[index] -= save;
	SpawnDamage (te_sparks, point, normal, save);

	return save;
}

#ifdef MONSTERS_OK

void M_ReactToDamage (edict_t *targ, edict_t *attacker)
{
	if (!(attacker->client) && !(attacker->svflags & SVF_MONSTER))
		return;

	if (attacker == targ || attacker == targ->enemy)
		return;

	// if we are a good guy monster and our attacker is a player
	// or another good guy, do not get mad at them
	if (targ->monsterinfo.aiflags & AI_GOOD_GUY)
	{
		if (attacker->client || (attacker->monsterinfo.aiflags & AI_GOOD_GUY))
			return;	 
	}

	// we now know that we are not both good guys

	// if attacker is a client, get mad at them because he's good and we're not
	if (attacker->client)
	{
		targ->monsterinfo.aiflags &= ~AI_SOUND_TARGET;

		// this can only happen in coop (both new and old enemies are clients)
		// only switch if can't see the current enemy
		if (targ->enemy && targ->enemy->client)
		{
			if (visible(targ, targ->enemy))
			{
				targ->oldenemy = attacker;
				return;
			}
			targ->oldenemy = targ->enemy;
		}
		targ->enemy = attacker;
		if (!(targ->monsterinfo.aiflags & AI_DUCKED))
			FoundTarget (targ);
		return;
	}

	// it's the same base (walk/swim/fly) type and a different classname and it's not a tank
	// (they spray too much), get mad at them
	if (((targ->flags & (FL_FLY|FL_SWIM)) == (attacker->flags & (FL_FLY|FL_SWIM))) &&
		 (strcmp (targ->classname, attacker->classname) != 0) &&
		 (strcmp(attacker->classname, "monster_tank") != 0) &&
		 (strcmp(attacker->classname, "monster_supertank") != 0) &&
		 (strcmp(attacker->classname, "monster_makron") != 0) &&
		 (strcmp(attacker->classname, "monster_jorg") != 0) )
	{
		if (targ->enemy && targ->enemy->client)
			targ->oldenemy = targ->enemy;
		targ->enemy = attacker;
		if (!(targ->monsterinfo.aiflags & AI_DUCKED))
			FoundTarget (targ);
	}
	// if they *meant* to shoot us, then shoot back
	else if (attacker->enemy == targ)
	{
		if (targ->enemy && targ->enemy->client)
			targ->oldenemy = targ->enemy;
		targ->enemy = attacker;
		if (!(targ->monsterinfo.aiflags & AI_DUCKED))
			FoundTarget (targ);
	}
	// otherwise get mad at whoever they are mad at (help our buddy) unless it is us!
	else if (attacker->enemy && attacker->enemy != targ)
	{
		if (targ->enemy && targ->enemy->client)
			targ->oldenemy = targ->enemy;
		targ->enemy = attacker->enemy;
		if (!(targ->monsterinfo.aiflags & AI_DUCKED))
			FoundTarget (targ);
	}
}

#endif

qboolean CheckTeamDamage (edict_t *targ, edict_t *attacker)
{
		//FIXME make the next line real and uncomment this block
		// if ((ability to damage a teammate == OFF) && (targ's team == attacker's team))
	// TEAM CODE - LM_JORM
	if (targ == attacker || matchstate == MATCH_RAILGUN_INPLAY)
		return false;
	if (attacker->client && targ->client && (OnSameTeam(attacker, targ)))
		return true;
	return false;
}

void T_Damage (edict_t *targ, edict_t *inflictor, edict_t *attacker, vec3_t dir, vec3_t point, vec3_t normal, int damage, int knockback, int dflags, int mod)
{
	gclient_t	*client;
	int			take;
	int			vampdrain;
	int			save;
	int			asave;
	int			psave;
	int			te_sparks;

	if (Match_InCountdown())
		return;
	
	if (!targ->takedamage)
		return;

	// friendly fire avoidance
	// if enabled you can't hurt teammates (but you can hurt yourself)
	// knockback still occurs
	if ((targ != attacker) && (deathmatch->value || coop->value))
	{
		if (OnSameTeam (targ, attacker))
		{
			if (	
					(   ((int)(dmflags->value)) & DF_NO_FRIENDLY_FIRE   )  && 
					!(dflags & DAMAGE_NO_PROTECTION) &&
					!(mod & MOD_TELEFRAG)   
				)
			{
				damage = 0;
			}
			else
				mod |= MOD_FRIENDLY_FIRE;
		}
	}
	meansOfDeath = mod;

	// easy mode takes half damage
	if (skill->value == 0 && deathmatch->value == 0 && targ->client)
	{
		damage *= 0.5;
		if (!damage)
			damage = 1;
	}

	client = targ->client;

	if (dflags & DAMAGE_BULLET)
		te_sparks = TE_BULLET_SPARKS;
	else
		te_sparks = TE_SPARKS;

	VectorNormalize(dir);

// bonus damage for suprising a monster
	if (!(dflags & DAMAGE_RADIUS) && (targ->svflags & SVF_MONSTER) && (attacker->client) && (!targ->enemy) && (targ->health > 0))
		damage *= 2;

	if (targ->flags & FL_NO_KNOCKBACK)
		knockback = 0;

	// apply Damage rune
	damage = DamageRuneHook(targ, inflictor, attacker, damage, knockback, dflags);

// figure momentum add
	if (!(dflags & DAMAGE_NO_KNOCKBACK))
	{
		if ((knockback) && (targ->movetype != MOVETYPE_NONE) && (targ->movetype != MOVETYPE_BOUNCE) && (targ->movetype != MOVETYPE_PUSH) && (targ->movetype != MOVETYPE_STOP))
		{
			vec3_t	kvel;
			float	mass;

			if (targ->mass < 50)
				mass = 50;
			else
				mass = targ->mass;

			if (targ->client  && attacker == targ)
				VectorScale (dir, 1600.0 * (float)knockback / mass, kvel);	// the rocket jump hack...
			else
				VectorScale (dir, 500.0 * (float)knockback / mass, kvel);
			
#ifdef WEAP_BALANCE_OK	
			if ((int)ctfflags->value & CTF_WEAP_BALANCE) //a little extra umph to knockback
			{
				if (targ->client  && attacker == targ)
					VectorScale (dir, 1800.0 * (float)knockback / mass, kvel);	// the rocket jump hack...
				else
					VectorScale (dir, 800.0 * (float)knockback / mass, kvel);
			}
#endif
			if (targ->groundentity)
			{
				if (kvel[2] < 0)
					kvel[2] = 0;
			}
			VectorAdd (targ->velocity, kvel, targ->velocity);
		}
	}

	take = damage;
	save = 0;

	// check for godmode
	if ( (targ->flags & FL_GODMODE) && !(dflags & DAMAGE_NO_PROTECTION) )
	{
		take = 0;
		save = damage;
		SpawnDamage (te_sparks, point, normal, save);
	}

	// check for invincibility
	if ((client && client->invincible_framenum > level.framenum ) && !(dflags & DAMAGE_NO_PROTECTION))
	{
		if (targ->pain_debounce_time < level.time)
		{
			gi.sound(targ, CHAN_ITEM, gi.soundindex("items/protect4.wav"), 1, ATTN_NORM, 0);
			targ->pain_debounce_time = level.time + 2;
		}
		take = 0;
		save = damage;
	}

	psave = CheckPowerArmor (targ, point, normal, take, dflags);
	take -= psave;

	// apply Resist rune
	take = ResistRuneHook(targ, inflictor, attacker, take, knockback, dflags);

	// armor protect from teammates...only protect normal armor
	if (((int) ctfflags->value & CTF_TEAM_ARMOR_PROTECT) &&
	    (OnSameTeam (targ, attacker)) &&
	    (targ != attacker))
	  asave = 0;
	else
	{
	  asave = CheckArmor (targ, point, normal, take, te_sparks, dflags);
	  take -= asave;
	}

	//treat cheat/powerup savings the same as armor
	asave += save;

	// team damage avoidance
	if (!(dflags & DAMAGE_NO_PROTECTION) && CheckTeamDamage (targ, attacker))
		return;

	// BUZZKILL - ADVANCED ANALYTICS - START
	if (attacker && attacker->client)
	{
		if (Q_stricmp(attacker->client->pers.weapon->classname, "weapon_railgun") == 0)
		{
			stats_add(attacker, STATS_RAIL_HIT, 1); // BUZZKILL - IMPROVED ANALYTICS - RAIL STATS
			stats_add(attacker, SQL_RAIL_HIT, 1); // BUZZKILL - SQLITE STATS - RAIL STATS
		}
		// Note: Damage given and received is not currently working - causes frequent crashes
		/*if (targ && targ->client && damage && mod != MOD_TELEFRAG)
		{
			stats_add(attacker, STATS_DAMAGE_OUT, damage);
			stats_add(targ, STATS_DAMAGE_IN, damage);
		}*/
	}
	// BUZZKILL - ADVANCED ANALYTICS - END

// do the damage
	if (take)
	{
		if ((targ->svflags & SVF_MONSTER) || (client))
			SpawnDamage (TE_BLOOD, point, normal, take);
		else
			SpawnDamage (te_sparks, point, normal, take);


		targ->health = targ->health - take;

		if (attacker && attacker->client && attacker->client->rune)   //added by Vampire - if the attacker is this client
		{                                                             // and the client has a rune
			if ((attacker->client->rune->runetype == RUNE_VAMP)&&(attacker!=targ))   // if the rune is the VAMPIRE rune and the target is not himself
			{
				if (Q_stricmp(targ->classname,"player") == 0)                     // if the target is a player,
                {
					vampdrain = attacker->health + (take >> 1); // take half of the health removed from the player
					if (vampdrain < 250)
						attacker->health = vampdrain;        // and add it to the attackers health
					else
						attacker->health = 250;              // to a maximum of 250 health
					gi.sound(attacker, CHAN_ITEM, gi.soundindex("brain/brnatck3.wav"), 1, ATTN_NORM, 0); //make the vampiric sound
					//gi.bprintf(PRINT_MEDIUM,"sucking the life from %s\n",targ->classname);   //for debugging purposes
				}
				else if (Q_stricmp(targ->classname, "bodyque") == 0)      // if the target is a dead body.  NOTE: the grapple classname = 'noclass'
				{
					vampdrain = attacker->health + (take >> 2); // take quarter of the health removed from the corpse
					if (vampdrain < 250)
						attacker->health = vampdrain;        // and add it to the attackers health
					else
						attacker->health = 250;              // to a maximum of 250 health
					gi.sound(attacker, CHAN_ITEM, gi.soundindex("brain/brnatck3.wav"), 1, ATTN_NORM, 0); //make the vampiric sound
					//gi.bprintf(PRINT_MEDIUM,"sucking the life from %s\n",targ->classname);   //for debugging purposes
				}
			}
		}




		// LM_JORM -- CTF Track those who hit the flag carrier
		if ((redflag  &&  redflag->owner == targ)	||
			(blueflag && blueflag->owner == targ))
		{
			if (attacker && attacker->client)
				attacker->client->hit_carrier_time = level.time;
				gi.sound(attacker, CHAN_ITEM, gi.soundindex("fc-hit.wav"), 1, ATTN_NORM, 0); // plays Q3 'hit' sound when FC successfully attacked (must have in pak or quake2\lmctf\sound directory)
		}
		// END LM_JORM
			
		if (targ->health <= 0)
		{
			if ((targ->svflags & SVF_MONSTER) || (client))
				targ->flags |= FL_NO_KNOCKBACK;
			Killed (targ, inflictor, attacker, take, point);
			return;
		}
	}

	//no monsters
	//bat
#ifdef MONSTERS_OK
	if (targ->svflags & SVF_MONSTER)
	{
		M_ReactToDamage (targ, attacker);
		if (!(targ->monsterinfo.aiflags & AI_DUCKED) && (take))
		{
			targ->pain (targ, attacker, knockback, take);
			// nightmare mode monsters don't go into pain frames often
			if (skill->value == 3)
				targ->pain_debounce_time = level.time + 5;
		}
	}
	else if (client)
#else	
	if (client)
#endif
	{
		if (!(targ->flags & FL_GODMODE) && (take))
			targ->pain (targ, attacker, knockback, take);
	}
	else if (take)
	{
		if (targ->pain)
			targ->pain (targ, attacker, knockback, take);
	}

	// add to the damage inflicted on a player this frame
	// the total will be turned into screen blends and view angle kicks
	// at the end of the frame
	if (client)
	{
		client->damage_parmor += psave;
		client->damage_armor += asave;
		client->damage_blood += take;
		client->damage_knockback += knockback;
		VectorCopy (point, client->damage_from);
	}
}


/*
============
T_RadiusDamage
============
*/
void T_RadiusDamage (edict_t *inflictor, edict_t *attacker, float damage, edict_t *ignore, float radius, int mod)
{
	float	points;
	edict_t	*ent = NULL;
	vec3_t	v;
	vec3_t	dir;

#ifdef WEAP_BALANCE_OK	
	float vlength, adjuster; //surt weaponbalance
#endif

	while ((ent = findradius(ent, inflictor->s.origin, radius)) != NULL)
	{
		if (ent == ignore)
			continue;
		if (!ent->takedamage)
			continue;

		VectorAdd (ent->mins, ent->maxs, v);
		VectorMA (ent->s.origin, 0.5, v, v);
		VectorSubtract (inflictor->s.origin, v, v);

#ifdef WEAP_BALANCE_OK	
		if ((int)ctfflags->value & CTF_WEAP_BALANCE)
		{
			vlength = VectorLength(v); //hopefully in id-units
			//'corrected' radius damage formula
			if (vlength < 1)
				vlength = 0; //no negatives
			if (radius < 1)
				radius = 1; //no divide by zero, no negatives
			adjuster = 1 - (vlength / radius);
			//as vlength approaches radius, adjuster approaches zero
			//we then multiply this value into the damage, so that
			//damage approaches zero at the radius of the explosion
			points = damage * adjuster;
			//assuming id calculated the vector length correctly, then
			//this should be a drop off of r over the radius, making
			//it worst to be very close to the center of an explosion,
			//but also allowing you to 'feel' a big explosion nearby
		}
		else //original id code
			points = damage - 0.5 * VectorLength (v);
#else
		points = damage - 0.5 * VectorLength (v);
#endif

		if (ent == attacker)
			points = points * 0.5;
		if (points > 0)
		{
			if (CanDamage (ent, inflictor))
			{
				VectorSubtract (ent->s.origin, inflictor->s.origin, dir);
				T_Damage (ent, inflictor, attacker, dir, inflictor->s.origin, vec3_origin, (int)points, (int)points, DAMAGE_RADIUS, mod);
			}
		}
	}
}
